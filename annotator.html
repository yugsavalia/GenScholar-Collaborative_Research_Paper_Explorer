<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale-1.0">
    <title>Annotator - {{ document.filename }}</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        
        /* This is the main container. 
          It MUST be position: relative for the layers to stack.
        */
        #pdf-container {
            width: 90%;
            max-width: 900px;
            margin: 20px auto;
            border: 1px solid #ccc;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            position: relative; 
            background-color: #525252;
            overflow: auto;
        }

        /* These 3 layers stack on top of each other.
          They MUST be position: absolute.
        */
        #pdf-canvas,
        #text-layer,
        #annotation-layer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
        }

        /* The text layer is for selection, not for viewing */
        #text-layer {
            opacity: 0.3; /* Show text slightly for debugging */
            color: transparent; /* Makes text invisible but selectable */
            pointer-events: auto; /* This layer captures mouse events */
        }
        
        /* The canvas is just the background image */
        #pdf-canvas {
            pointer-events: none; /* Clicks go "through" the canvas */
        }

        /* The annotation layer is for drawing red boxes */
        #annotation-layer {
            pointer-events: none; /* Clicks pass through */
        }

        /* PDF.js text layer styles.
          These are required for text selection to work.
        */
        .textLayer ::selection { background: rgba(0,0,255,0.3); }
        .textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }

        /* Individual annotation box */
        .annotation-box {
            position: absolute;
            background-color: rgba(255, 0, 0, 0.3);
            border: 2px solid red;
            box-sizing: border-box;
            pointer-events: all; /* Annotations ARE clickable */
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .annotation-box:hover {
            background-color: rgba(255, 0, 0, 0.5);
        }

        /* Temporary drawing rectangle (if not selecting text) */
        #temp-rect {
            position: absolute;
            border: 2px dashed #000;
            background-color: rgba(0, 0, 0, 0.1);
            pointer-events: none;
            box-sizing: border-box;
            display: none; /* Hidden by default */
            z-index: 10;
        }
    </style>
</head>
<body class="bg-gray-200">

    <!-- Header and Controls -->
    <header class="bg-gray-800 text-white p-4 shadow-md sticky top-0 z-20">
        <div class="container mx-auto flex justify-between items-center">
            <div>
                <a href="{% url 'pdf_list' %}" class="text-lg font-semibold hover:text-gray-300">&larr; Back to List</a>
                <span class="ml-4 text-gray-400">{{ document.filename }}</span>
            </div>
            <div class="flex items-center space-x-4">
                <button id="prev-page" class="px-3 py-1 bg-gray-600 rounded-md hover:bg-gray-500">Previous</button>
                <span>Page: <span id="page-num">1</span> / <span id="page-count">--</span></span>
                <button id="next-page" class="px-3 py-1 bg-gray-600 rounded-md hover:bg-gray-500">Next</button>
            </div>
        </div>
    </header>

    <!-- 
      PDF Viewer 
      The layers will be stacked inside this container.
    -->
    <div id="pdf-container">
        <canvas id="pdf-canvas"></canvas>
        <div id="text-layer" class="textLayer"></div>
        <div id="annotation-layer"></div>
        <div id="temp-rect"></div>
    </div>

    {{ document.id|json_script:"pdf-id" }}

    <script>
      document.addEventListener('DOMContentLoaded', () => {

        // --- Config and State ---
        const PDF_ID = JSON.parse(document.getElementById('pdf-id').textContent);
        const PDF_URL = `/pdf/${PDF_ID}/data/`; 
        const API_URL = `/api/pdf/${PDF_ID}/annotations/`;
        const API_DELETE_URL_BASE = `/api/annotation/`;

        let pdfDoc = null;
        let currentPage = 1;
        let scale = 1.5; // We'll start with 1.5 and let it be adjusted
        let currentAnnotations = [];
        let allAnnotations = [];

        // --- Drawing State ---
        let isDrawing = false;
        let startCoords = { x: 0, y: 0 };
        let tempRect = document.getElementById('temp-rect');

        // --- DOM Elements ---
        const canvas = document.getElementById('pdf-canvas');
        const ctx = canvas.getContext('2d');
        const pageNumSpan = document.getElementById('page-num');
        const pageCountSpan = document.getElementById('page-count');
        const pdfContainer = document.getElementById('pdf-container');
        const textLayer = document.getElementById('text-layer');
        const annotationLayer = document.getElementById('annotation-layer');

        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // 1. Load the PDF Document
        pdfjsLib.getDocument(PDF_URL).promise.then(pdfDoc_ => {
            console.log('PDF document loaded successfully.');
            pdfDoc = pdfDoc_;
            pageCountSpan.textContent = pdfDoc.numPages;
            loadAllAnnotations().then(() => {
                console.log('Annotations loaded, rendering page 1.');
                renderPage(currentPage);
            });
        }).catch(err => {
            console.error('Failed to load PDF file.', err);
            alert('Failed to load PDF file. Check server logs.');
        });

        // 2. Render a Specific Page
        function renderPage(num) {
            console.log('renderPage(' + num + ') called.');
            pdfDoc.getPage(num).then(page => {
                console.log('Got page ' + num);
                
                // --- DYNAMIC SCALING (Robust version) ---
                const containerWidth = pdfContainer.clientWidth;
                const unscaledViewport = page.getViewport({ scale: 1 });
                scale = containerWidth / unscaledViewport.width; // Update global scale
                const viewport = page.getViewport({ scale: scale }); 
                // --- END DYNAMIC SCALING ---
                
                // Set dimensions for ALL layers and the container
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                textLayer.style.height = `${viewport.height}px`;
                textLayer.style.width = `${viewport.width}px`;
                annotationLayer.style.height = `${viewport.height}px`;
                annotationLayer.style.width = `${viewport.width}px`;
                pdfContainer.style.height = `${viewport.height}px`; // This makes the container visible

                // Render PDF page *image* to canvas
                const renderContext = {
                    canvasContext: ctx,
                    viewport: viewport
                };
                
                page.render(renderContext).promise.then(() => {
                    console.log('Page ' + num + ' canvas rendered.');
                    drawAnnotations();
                    
                    // --- NEW: Render Text Layer ---
                    return page.getTextContent();
                }).then(textContent => {
                    console.log('Got text content, rendering text layer.');
                    // Clear previous text
                    textLayer.innerHTML = ''; 
                    
                    // Pass the text content to PDF.js's renderer
                    pdfjsLib.renderTextLayer({
                        textContent: textContent,
                        container: textLayer,
                        viewport: viewport,
                        textDivs: []
                    });
                    console.log('Text layer rendered.');
                }).catch(err => {
                    console.error('Page ' + num + ' rendering failed:', err);
                    alert('A critical error occurred while rendering the PDF page. Please check the console.');
                });
            });
            pageNumSpan.textContent = num;
        }

        // 3. Annotation Data Handling
        async function loadAllAnnotations() {
            // ... (rest of the function is identical, removed for brevity) ...
            try {
                const response = await fetch(API_URL);
                if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                allAnnotations = await response.json();
            } catch (err) { console.error('Failed to load annotations:', err); }
        }
        async function saveAnnotation(rect, comment) {
            // ... (rest of the function is identical, removed for brevity) ...
            const annotationData = { page: currentPage, comment: comment, rect: rect };
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(annotationData)
                });
                const result = await response.json();
                if (result.success) {
                    annotationData.id = result.id;
                    allAnnotations.push(annotationData);
                    drawAnnotations(); 
                }
            } catch (err) { console.error('Failed to save annotation:', err); }
        }
        async function deleteAnnotation(annotationId, element) {
            // ... (rest of the function is identical, removed for brevity) ...
            element.remove();
            try {
                const response = await fetch(`${API_DELETE_URL_BASE}${annotationId}/delete/`, { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    allAnnotations = allAnnotations.filter(a => a.id !== annotationId);
                } else {
                    drawAnnotations();
                }
            } catch (err) { console.error('Failed to delete annotation:', err); }
        }

        // 4. Drawing Annotations on the Page
        function drawAnnotations() {
            // ... (rest of the function is identical, removed for brevity) ...
            annotationLayer.innerHTML = '';
            currentAnnotations = allAnnotations.filter(a => a.page_number === currentPage);
            currentAnnotations.forEach(ann => {
                const [x, y, width, height] = ann.coordinates;
                const box = document.createElement('div');
                box.className = 'annotation-box';
                box.style.left = `${x}px`;
                box.style.top = `${y}px`;
                box.style.width = `${width}px`;
                box.style.height = `${height}px`;
                box.title = ann.comment;
                box.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    if (confirm(`Delete this annotation?\n\nComment: ${ann.comment}`)) {
                        deleteAnnotation(ann.id, box);
                    }
                });
                annotationLayer.appendChild(box);
            });
        }

        // 5. Page Navigation
        document.getElementById('prev-page').addEventListener('click', () => {
            if (currentPage <= 1) return;
            currentPage--;
            renderPage(currentPage);
        });
        
        document.getElementById('next-page').addEventListener('click', () => {
            if (currentPage >= pdfDoc.numPages) return;
            currentPage++;
            renderPage(currentPage);
        });

        // 6. --- NEW Annotation Logic (Handles Text Selection) ---
        
        // This function gets the coordinates of the selected text
        function getSelectionRect() {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return null;
            
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            const containerRect = textLayer.getBoundingClientRect();

            // Check if selection is inside our container
            if (rect.top < containerRect.top || rect.bottom > containerRect.bottom) {
                return null;
            }

            // Convert to relative coordinates
            const x = rect.left - containerRect.left;
            const y = rect.top - containerRect.top;
            const width = rect.width;
            const height = rect.height;

            if (width < 2 || height < 2) return null;

            return [x, y, width, height];
        }

        // We now listen for mouse events on the TEXT LAYER
        textLayer.addEventListener('mousedown', (e) => {
            // Don't start drawing if we're clicking a text span
            if (e.target.tagName === 'SPAN') {
                isDrawing = false;
                return;
            }
            
            isDrawing = true;
            const rect = textLayer.getBoundingClientRect();
            startCoords.x = e.clientX - rect.left;
            startCoords.y = e.clientY - rect.top;

            tempRect.style.display = 'block';
            tempRect.style.left = `${startCoords.x}px`;
            tempRect.style.top = `${startCoords.y}px`;
            tempRect.style.width = '0px';
            tempRect.style.height = '0px';
        });

        textLayer.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;

            const rect = textLayer.getBoundingClientRect();
            let currentX = e.clientX - rect.left;
            let currentY = e.clientY - rect.top;

            let width = currentX - startCoords.x;
            let height = currentY - startCoords.y;
            let newLeft = startCoords.x;
            let newTop = startCoords.y;

            if (width < 0) { width = Math.abs(width); newLeft = currentX; }
            if (height < 0) { height = Math.abs(height); newTop = currentY; }

            tempRect.style.left = `${newLeft}px`;
            tempRect.style.top = `${newTop}px`;
            tempRect.style.width = `${width}px`;
            tempRect.style.height = `${height}px`;
        });

        textLayer.addEventListener('mouseup', () => {
            let selectionRect = getSelectionRect();
            
            if (selectionRect) {
                // --- We selected text ---
                isDrawing = false;
                tempRect.style.display = 'none';
                
                const comment = prompt('Enter annotation comment:');
                if (comment) {
                    saveAnnotation(selectionRect, comment);
                }
                // Clear selection
                window.getSelection().removeAllRanges();

            } else if (isDrawing) {
                // --- We drew a box ---
                isDrawing = false; 
                tempRect.style.display = 'none'; 

                const rect = [
                    parseFloat(tempRect.style.left),
                    parseFloat(tempRect.style.top),
                    parseFloat(tempRect.style.width),
                    parseFloat(tempRect.style.height)
                ];

                if (rect[2] < 5 || rect[3] < 5) return;

                const comment = prompt('Enter annotation comment:');
                if (comment) {
                    saveAnnotation(rect, comment);
                }
            }
        });
        
      }); // --- End of DOMContentLoaded listener ---
    </script>
</body>
</html>